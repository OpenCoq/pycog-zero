name: Generate Next Steps Issues

on:
  workflow_dispatch:
    inputs:
      force_recreate:
        description: 'Force recreate all issues (will close existing ones)'
        required: false
        default: 'false'
        type: boolean
  schedule:
    # Run weekly on Mondays at 9 AM UTC to check for new tasks
    - cron: '0 9 * * 1'

env:
  ROADMAP_FILE: 'AGENT-ZERO-GENESIS.md'

jobs:
  generate-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Parse roadmap and create issues
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Read the roadmap file
          const roadmapContent = fs.readFileSync(process.env.ROADMAP_FILE, 'utf8');
          
          // Parse the "Next Development Steps" section
          const nextStepsMatch = roadmapContent.match(/## Next Development Steps\n\n([\s\S]*?)(?=\n## |$)/);
          if (!nextStepsMatch) {
            console.log('No "Next Development Steps" section found');
            return;
          }
          
          const nextStepsContent = nextStepsMatch[1];
          
          // Parse each timeline section
          const timelineRegex = /(\d+)\.\s\*\*([^*]+)\*\*:\s*\n((?:\s*-\s\[[^\]]*\][^\n]*\n?)*)/g;
          const timelines = [];
          let match;
          
          while ((match = timelineRegex.exec(nextStepsContent)) !== null) {
            const [, number, title, tasksText] = match;
            const tasks = [];
            
            // Parse individual tasks
            const taskRegex = /\s*-\s\[([^\]]*)\]\s(.+)/g;
            let taskMatch;
            while ((taskMatch = taskRegex.exec(tasksText)) !== null) {
              const [, status, description] = taskMatch;
              tasks.push({
                completed: status.trim() === 'x',
                description: description.trim()
              });
            }
            
            timelines.push({
              number: parseInt(number),
              title: title.trim(),
              tasks: tasks
            });
          }
          
          console.log(`Found ${timelines.length} timeline sections`);
          
          // Get existing issues to avoid duplicates
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'next-steps',
            state: 'all'
          });
          
          const existingTitles = new Set(existingIssues.data.map(issue => issue.title));
          
          // Force recreate option
          const forceRecreate = context.payload.inputs?.force_recreate === 'true';
          if (forceRecreate) {
            console.log('Force recreate enabled - closing existing next-steps issues');
            for (const issue of existingIssues.data) {
              if (issue.state === 'open') {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
              }
            }
            existingTitles.clear();
          }
          
          // Create issues for incomplete tasks
          let createdCount = 0;
          
          for (const timeline of timelines) {
            const timelineLabel = timeline.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
            
            for (const task of timeline.tasks) {
              if (!task.completed) {
                const issueTitle = `[${timeline.title}] ${task.description}`;
                
                if (!existingTitles.has(issueTitle)) {
                  const issueBody = [
                    `## Timeline: ${timeline.title}`,
                    '',
                    'This task is part of the Agent-Zero Genesis development roadmap.',
                    '',
                    '### Task Description',
                    task.description,
                    '',
                    '### Context',
                    `This is a ${timeline.title.toLowerCase()} priority task from the [Agent-Zero Genesis roadmap](${context.payload.repository.html_url}/blob/main/${process.env.ROADMAP_FILE}#next-development-steps).`,
                    '',
                    '### Acceptance Criteria',
                    '- [ ] Task implementation completed',
                    '- [ ] Code tested and validated',
                    '- [ ] Documentation updated if needed',
                    '- [ ] Update roadmap checkbox when complete',
                    '',
                    '---',
                    '*This issue was automatically generated from the project roadmap.*'
                  ].join('\n');

                  try {
                    const issue = await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: issueTitle,
                      body: issueBody,
                      labels: ['next-steps', timelineLabel, 'roadmap']
                    });
                    
                    console.log(`Created issue: ${issueTitle}`);
                    createdCount++;
                  } catch (error) {
                    console.error(`Failed to create issue "${issueTitle}": ${error.message}`);
                  }
                } else {
                  console.log(`Issue already exists: ${issueTitle}`);
                }
              }
            }
          }
          
          console.log(`\nSummary:`);
          console.log(`- Found ${timelines.length} timeline sections`);
          console.log(`- Created ${createdCount} new issues`);
          console.log(`- Skipped ${existingTitles.size} existing issues`);
          
          // Create a summary comment if running manually
          if (context.eventName === 'workflow_dispatch') {
            const summaryLines = [
              '## Next Steps Issues Generation Summary',
              '',
              '**Roadmap Processing:**',
              `- Found ${timelines.length} timeline sections in \`${process.env.ROADMAP_FILE}\``,
              `- Processed ${timelines.reduce((sum, t) => sum + t.tasks.length, 0)} total tasks`,
              '',
              '**Issues Created:**',
              `- ✅ Created ${createdCount} new issues`,
              `- ⏭️ Skipped ${existingTitles.size} existing issues`,
              `- 🔄 Force recreate: ${forceRecreate ? 'Yes' : 'No'}`,
              '',
              '**Timeline Breakdown:**',
              ...timelines.map(t => `- **${t.title}**: ${t.tasks.filter(task => !task.completed).length} pending tasks`),
              '',
              'All new issues have been labeled with:',
              '- `next-steps` (for easy filtering)',
              '- `roadmap` (indicates automatic generation)',
              '- Timeline-specific labels (e.g., `immediate`, `short-term`)',
              '',
              '---',
              `*View all next-steps issues: [Issues with next-steps label](${context.payload.repository.html_url}/issues?q=is%3Aissue+label%3Anext-steps)*`
            ];
            
            const summaryBody = summaryLines.join('\n');

            // Find if there's already a tracking issue
            const trackingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'tracking,next-steps-generation',
              state: 'open'
            });
            
            if (trackingIssues.data.length > 0) {
              // Add comment to existing tracking issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: trackingIssues.data[0].number,
                body: summaryBody
              });
            } else {
              // Create new tracking issue
              const trackingTitle = 'Next Steps Generation Tracking';
              const trackingBody = [
                'This issue tracks the automatic generation of next steps issues from the project roadmap.',
                '',
                summaryBody
              ].join('\n');
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: trackingTitle,
                body: trackingBody,
                labels: ['tracking', 'next-steps-generation']
              });
            }
          }
